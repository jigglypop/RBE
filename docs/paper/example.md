아래 예시는 **“packed 128 bit” 값 하나가 실제로 어떤 필드를 담고 있으며, 그 필드들이 가상의 가중치 함수를 어떻게 구성하는지**를 한눈에 보여 줍니다.

---

#### 1. 예제 packed 값과 필드 디코딩

```text
Packed 128-bit value (hex):
0x00000007F921FB67E0000009A5000FFD
```

| 필드        | 비트 폭      | 추출 결과         |
| ----------- | ------------ | ----------------- |
| quadrant    | 2 bit        | `1`               |
| freq        | 11 bit       | `1023`            |
| amp         | 12 bit       | `2048`            |
| phase       | 12 bit       | `1234`            |
| r (radial)  | 32 bit (f32) | `0.5`             |
| θ (angular) | 32 bit (f32) | `1.5707964 ≈ π/2` |

(위 표에서 r·θ는 IEEE-754 float32 비트를 그대로 해석한 값입니다.)

---

#### 2. 이 값이 만들어 내는 “블록 내 가중치” 예시

가중치 $w_{ij}$ 를 만드는 단계를 단순화하여 보여 주면:

1. **기본 파형 선택** (quadrant = 1 → `sin` 사용)

   $$
   b_{ij} \;=\; \sin\!\bigl( 2\pi\;\tfrac{\text{freq}}{64}\,(i+j)\;+\;\phi \bigr),
   \qquad
   \phi \;=\; \tfrac{\text{phase}}{4095}\,2\pi
   $$

2. **진폭 스케일**

   $$
   a \;=\; \tfrac{\text{amp}}{4095} \approx 0.500\,1
   $$

3. **하이퍼볼릭(포앵카레) 보정**

   $$
   h \;=\; (1-r)\,\cos\theta \;=\; (1-0.5)\,\cos\!\bigl(\tfrac{\pi}{2}\bigr)=0
   $$

4. **최종 가중치**

   $$
   w_{ij} \;=\; a \cdot b_{ij} \cdot h
   $$

예를 들어 **행 10, 열 5** 위치에 대해 계산하면(블록 크기 64×64 가정):

```text
Example weight for position (row=10, col=5):  -0.000000
```

> ▶︎ r = 0.5, θ = π/2 이므로 $h = 0$ → 어떤 위치에서도 가중치가 0 에 수렴하는 특수한 케이스가 됨. r·θ 값을 살짝만 바꿔도 바로 비(非)영이 됩니다.

---

### 이렇게 활용하세요

* **디버깅** — `PackedParam::r()` 처럼 인라인 헬퍼를 두면, 위와 같은 실수 값을 IDE / 로그에서 즉시 확인할 수 있습니다.
* **테스트** — 필드별 엣지 케이스(예: freq=0, r→1)에 대해 `weight_val`이 폭주하지 않는지 단위 테스트에 넣으면 수치 안정성을 보장할 수 있습니다.
* **시각화** — 행·열 범위를 돌며 `w_{ij}`를 heat-map으로 그리면, 한 블록이 표현하는 패턴이 직관적으로 보입니다.

> 이처럼 **128 bit 패킹을 유지**하면서도, 간단한 디코더 스크립트(위 Python 예제)만 있으면 내부 구조와 수식을 “눈으로” 확인할 수 있습니다.
