# 2. 인코딩: 원본 데이터로부터 이중-코어 파라미터 추출

## 2.1. 개요

인코딩(Encoding)은 표준 부동소수점 형태로 표현된 원본 가중치 행렬(Source Matrix)을, 1장에서 정의한 `HybridEncodedBlock` 데이터 구조로 변환하는 과정이다. 이 과정은 단순한 데이터 압축을 넘어, 주어진 행렬이 가진 내재적 구조(inherent structure)를 분석하여 최적의 이중-코어 파라미터(`Packed128`)와 희소 잔차(Sparse Residuals)를 추출하는 고도의 분석 및 최적화 절차이다.

본 장에서는 인코딩 과정을 여러 단계의 파이프라인으로 나누어, 각 단계의 목표와 기술적 구현 방안을 상세히 서술한다.

## 2.2. 인코딩 파이프라인

전체 인코딩 과정은 다음과 같은 4단계의 파이프라인으로 구성된다.

1.  **상태-전이 코어(`hi`) 초기화**: 원본 행렬의 주파수 및 위상 특성을 분석하여, `hi` 필드의 이산적 상태(discrete state)에 대한 최적의 초기값을 결정한다.
2.  **연속계 코어(`lo`) 피팅**: 결정된 `hi` 상태를 기반으로, `lo` 필드의 연속계 파라미터(`r_fp32`, `theta_fp32`)를 최적화하여 원본 행렬의 거시적 패턴을 근사한다.
3.  **잔차 계산**: 1, 2단계에서 생성된 근사 행렬과 원본 행렬의 차이를 계산하여 잔차 행렬(Residual Matrix)을 생성한다.
4.  **잔차 압축**: 잔차 행렬을 주파수 도메인(DCT/DWT)으로 변환하고, 에너지 집중(Energy Compaction) 원리에 따라 가장 중요한 K개의 계수만을 추출하여 저장한다.

---

## 2.3. 1단계: 상태-전이 코어(`hi`) 초기화

`hi` 필드는 양자화된 이산 상태를 나타내므로, 표준적인 회귀(regression) 분석으로 값을 결정할 수 없다. 대신, 원본 행렬의 구조적 특성으로부터 최적의 상태를 추론하는 기법이 요구된다.

### 2.3.1. 주파수 분석 기반 초기화

원본 행렬 블록에 2D 고속 푸리에 변환(FFT)을 적용하여 주파수 스펙트럼을 분석한다.

1.  **지배적 주파수(Dominant Frequency) 추출**: 스펙트럼에서 가장 큰 에너지를 가지는 주파수 성분 `(fx, fy)`를 찾는다. 이는 `hi` 필드의 `frequency_quant` 값의 초기치로 사용된다.
2.  **위상(Phase) 추출**: 해당 주파수 성분의 위상각을 계산한다. 이 위상각은 기저 함수(`sin`, `cos` 등)의 초기 상태를 결정하는 데 사용되어 `phase_state` 비트의 초기값을 설정한다.

이 방법은 원본 행렬이 강한 주기성을 가질 때 매우 효과적이다.

### 2.3.2. 소규모 탐색 기반 최적화

또 다른 접근법은 후보가 되는 몇몇 `hi` 상태 값들에 대해 소규모 최적화를 수행하는 것이다.

1.  주파수 분석 또는 경험적 규칙에 기반하여 `hi` 상태의 후보군(candidate set)을 몇 개 선정한다.
2.  각 후보 `hi` 상태에 대해, 다음 단계인 **2.4절의 `lo` 필드 피팅**을 간략히 수행한다.
3.  피팅 후의 잔차 오차가 가장 작은 `hi` 상태를 최종 초기값으로 선택한다.

이 방법은 연산 비용이 더 높지만, 더 정확한 초기 상태를 찾아낼 수 있다.

## 2.4. 2단계: 연속계 코어(`lo`) 피팅

1단계에서 `hi` 코어의 상태가 결정되면, 이는 가중치를 생성하는 기저 함수의 기본 형태를 정의한다. 2단계의 목표는 이 기본 형태를 바탕으로, `lo` 코어의 두 연속 파라미터(`r_fp32`, `theta_fp32`)를 최적화하여 원본 행렬 `S`를 가장 잘 근사하는 것이다.

생성될 가중치 `W`는 `r_fp32`와 `theta_fp32`에 대한 함수 `W(r, θ)`로 표현할 수 있다. 우리의 목표는 `|| S - W(r, θ) ||²`를 최소화하는 `r`과 `θ`를 찾는 것이다. 이는 비선형 최소제곱 문제(Non-linear Least Squares Problem)에 해당하며, 다음과 같은 수치 최적화 기법으로 해결할 수 있다.

-   **Gauss-Newton 알고리즘** 또는 **Levenberg-Marquardt 알고리즘**: 이 반복적 최적화 알고리즘들은 `W`의 자코비안 행렬(Jacobian matrix) `J = [∂W/∂r, ∂W/∂θ]`를 사용하여 `r`과 `θ`의 최적 업데이트 값을 효율적으로 찾아낸다.

이 과정을 통해 `hi` 코어의 구조적 패턴에 `lo` 코어의 연속적 스케일 및 위상 변이가 더해져, 원본 행렬의 핵심적인 특징을 대부분 표현하는 근사 행렬이 생성된다.

## 2.5. 3 & 4단계: 잔차 계산 및 압축

### 2.5.1. 잔차 행렬 계산

`hi`와 `lo` 코어의 최적화된 파라미터로 근사 행렬 `W_approx = W(hi_opt, lo_opt)`를 생성한다. 그 후, 원본 행렬 `S`와의 차이를 계산하여 잔차 행렬 `R`을 얻는다.

`R = S - W_approx`

이 잔차 행렬 `R`은 두 코어가 표현하지 못한 고주파 성분, 비선형성, 또는 국소적 특이점(local singularities) 등의 정보를 담고 있다.

### 2.5.2. 주파수 변환 및 희소화(Sparsification)

잔차 행렬 `R`은 종종 희소하거나, 특정 주파수 대역에 에너지가 집중되는 특성을 보인다. 이 특성을 이용하여 잔차를 효율적으로 압축한다.

1.  **변환(Transform)**: `R`에 2D 이산 코사인 변환(DCT) 또는 이산 웨이블릿 변환(DWT)을 적용한다. 이 변환들은 신호의 에너지를 소수의 계수에 집중시키는 '에너지 집중' 특성이 뛰어나다.
2.  **선택(Select)**: 변환된 행렬에서 절대값이 가장 큰 상위 `K`개의 계수(coefficients)만을 선택한다. `K` 값은 목표 압축률과 복원 정확도 사이의 트레이드오프(trade-off)를 결정하는 중요한 하이퍼파라미터이다.
3.  **저장(Store)**: 선택된 `K`개 계수의 값(value)과 그 위치 정보(index)를 `HybridEncodedBlock`의 `residuals` 벡터에 저장한다.

이 과정을 통해, 원본 행렬의 거의 모든 정보가 `Packed128` 시드와 몇 개의 희소 잔차 계수라는 지극히 압축된 형태로 인코딩된다.

---

## 2.6. 인코딩 예제: 4x4 행렬 변환 과정

이론적 설명을 구체화하기 위해, 간단한 4x4 원본 행렬 `S`가 `HybridEncodedBlock`으로 인코딩되는 과정을 단계별로 추적한다.

**원본 행렬 `S`**: `sin(π * x)` 형태의 단순한 주기성을 가진다고 가정한다. (값은 0~1로 정규화)

```
S =
[[ 0.50, 0.95, 0.95, 0.50 ],
 [ 0.50, 0.95, 0.95, 0.50 ],
 [ 0.50, 0.95, 0.95, 0.50 ],
 [ 0.50, 0.95, 0.95, 0.50 ]]
```

### 1단계: `hi` 코어 초기화 (주파수 분석)

1.  **FFT 적용**: 행렬 `S`에 2D FFT를 적용하여 주파수 도메인으로 변환한다.
2.  **지배적 주파수 식별**: FFT 결과, `x`축 방향으로 한 번의 주기(`fx=1`)를 가지는 주파수 성분의 에너지가 가장 크게 나타난다. `y`축 방향의 주파수(`fy=0`)는 0이다.
3.  **`hi` 필드 값 결정**:
    *   `frequency_quant`는 `(fx=1, fy=0)`에 해당하는 값으로 양자화된다.
    *   해당 주파수의 위상(phase)은 90도(`π/2`)이므로, 기저 함수는 `sin` 계열이 된다. 따라서 `phase_state`는 `00(sin)`으로 설정된다.
    *   `function_selector`는 `sin` 함수를 사용하도록 설정된다.

**결과**: `hi`의 주요 비트 필드가 `(phase=00, freq_x=1, func=sin)` 상태로 초기화된다.

### 2단계: `lo` 코어 피팅 (최소제곱법)

`hi`에 의해 기본 패턴 `W_base = A * sin(π * x)`가 결정되었다 (여기서 `A`는 `amplitude_quant` 값). 이제 `lo`의 `r_fp32`(스케일)와 `theta_fp32`(오프셋)를 최적화하여 `W(r,θ) = r * W_base + θ`가 원본 행렬 `S`와 가장 유사해지도록 만든다.

**목표**: `Loss = || S - (r * W_base + θ) ||²` 최소화

Levenberg-Marquardt 알고리즘을 수 회 반복한 결과, 다음과 같은 최적의 파라미터를 얻었다고 가정한다.

-   `r_fp32` = `1.05`
-   `theta_fp32` = `-0.02`

이 파라미터로 근사 행렬 `W_approx`를 생성한다.

```
W_approx =
[[ 0.48, 0.97, 0.97, 0.48 ],
 [ 0.48, 0.97, 0.97, 0.48 ],
 [ 0.48, 0.97, 0.97, 0.48 ],
 [ 0.48, 0.97, 0.97, 0.48 ]]
```

### 3단계: 잔차 행렬 계산

`R = S - W_approx`를 계산한다.

```
R =
[[ 0.02, -0.02, -0.2, 0.02 ],
 [ 0.02, -0.02, -0.2, 0.02 ],
 [ 0.02, -0.02, -0.2, 0.02 ],
 [ 0.02, -0.02, -0.2, 0.02 ]]
```

### 4단계: 잔차 압축 (DCT 및 희소화, K=2)

1.  **DCT 적용**: 잔차 행렬 `R`에 2D DCT를 적용한다.
    ```
    DCT(R) =
    [[ 0.00,  0.00,  0.00,  0.00 ],
     [-0.08, -0.08, -0.08, -0.08 ],
     [ 0.00,  0.00,  0.00,  0.00 ],
     [ 0.00,  0.00,  0.00,  0.00 ]]
    ```
    (설명을 위해 값이 단순화됨. 실제로는 다양한 저에너지 값들이 분포함)

2.  **상위 K개 선택**: `K=2`로 설정했으므로, 절대값이 가장 큰 2개의 계수를 선택한다. 하지만 이 예시에서는 0이 아닌 값이 4개이므로, 4개 중 2개를 선택했다고 가정한다.
    -   선택된 계수 1: `index=(1,0)`, `value=-0.08`
    -   선택된 계수 2: `index=(1,1)`, `value=-0.08`

3.  **최종 `HybridEncodedBlock` 저장**:

    ```rust
    HybridEncodedBlock {
        seed: Packed128 {
            hi: /* 1단계에서 결정된 비트 값 */,
            lo: /* 2단계에서 결정된 r,θ를 비트로 변환한 값 */,
        },
        residuals: vec![
            ResidualCoefficient { index: 4, value: -0.08 }, // (1,0) -> 1*4+0=4
            ResidualCoefficient { index: 5, value: -0.08 }, // (1,1) -> 1*4+1=5
        ],
        // ... 메타데이터
    }
    ```

이로써 원본 4x4 행렬(16개의 `f32` 값)이, 하나의 `Packed128` (16바이트)과 2개의 `ResidualCoefficient` (2 * (4+4) = 16바이트)로 압축되었다. 원본 64바이트 대비 32바이트로, 2:1 압축률을 달성했으며, 동시에 학습 가능한 파라미터 구조를 유지했다. 